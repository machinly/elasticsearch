[[query-string-syntax]]

==== 查询字符串语法

在 <<search-search,`search` API>> 中被用于 <<query-dsl-query-string-query>>
和 `q` 查询字符串参数的 ``微型语言'' 。

查询字符串被解析成一系列的词和运算符。一个词可以是单个的词 -- `quick` 或者 `brown` --
或者一个被双引号括起来的短语 -- `"quick brown"` ，这会以短语中单词的顺序搜索所有的单词。

允许自定义搜索 -- 可用的选项说明如下。

===== 字段名

如 <<query-dsl-query-string-query>> 所述， `default_field` 会作为搜索词被搜索，
但可以在查询语法中指定其他字段：

* 这里 `status` 字段包含 `active`

    status:active

* 这里 `title` 字段包含 `quick` 或者 `brown` 。如果省略OR运算符，将使用默认运算符

    title:(quick OR brown)
    title:(quick brown)

* 这里 `author` 字段包含精确短语 `"john smith"`

    author:"John Smith"

* 这里字段 `book.title`， `book.content` 或者 `book.date` 都包含 `quick` 或者 `brown` （
注意我们需要使用反斜杠来转义 `*` ）：

    book.\*:(quick brown)

* 这里字段 `title` 有非空值：

    _exists_:title

===== 通配符

通配符搜索能够在单个词上运行，使用 `?` 代替一个单个字符，使用 `*` 代替0个或更多个字符：

    qu?ck bro*

请注意，通配符查询可能会使用大量的内存，并且运行的非常糟糕，
想一想需要查询多少个词来匹配查询字符串 `"a* b* c*"`。

[WARNING]
=======
为了提高效率，纯通配符 `\*` 被重写为 <<query-dsl-exists-query,`exists`>> 查询。
 因此，通配符 `"field:*"` 将会匹配具有空值的文档，如下所示：
```
{
  "field": ""
}
```
\... 如果字段不存在或者设置一个显式的null值，则不会匹配，如下所示：
```
{
  "field": null
}
```
=======

[WARNING]
=======
在单词的开头允许使用通配符（例如 `"*ing"`）特别重，因为索引中的所有词都需要检查，以防止他们匹配。
通过设置 `allow_leading_wildcard` 为 `false` 可以将前导通配符禁用。
=======

仅应用在字符级别操作分析链的部分。因此，如果分析器执行小写和词干分析，则只应用小写：
对缺少某些字母的单词执行词干分析会是错误的。

通过将 `analyze_wildcard` 设置为真，将分析以 `*` 结尾的查询，
并通过确保第一个N-1标记的精确匹配以及最后一个标记的前缀匹配，从不同的标记构建一个布尔查询。

===== 正则表达式

正则表达式模式可以通过将它们包装在正斜杠（`"/"`）中来嵌入查询字符串中：

    name:/joh?n(ath[oa]n)/

正则表达式支持的语法在 <<regexp-syntax>> 中有解释。

[WARNING]
=======
`allow_leading_wildcard` 参数对正则表达式没有任何控制权。
下面的查询字符串将会强制Elasticsearch访问索引中每个词：

    /.*n/

谨慎使用！
=======

===== 模糊

我们可以使用 ``fuzzy'' 运算符搜索与我们的搜索词相似但不完全相同的词：

    quikc~ brwn~ foks~

这将使用
http://en.wikipedia.org/wiki/Damerau-Levenshtein_distance[Damerau-Levenshtein distance]
查找最多有两个变化的所有词，其中一个变化是插入，删除或者单个字符的替换，或者两个相邻字符的换位。

默认的编辑距离是 `2`，但编辑距离为1应足以捕获人为拼写错误的80%。它可以指定为：

    quikc~1

===== 邻近搜索

虽然一个短语查询（例如：`"john smith"`）期望所有的词有完全相同的顺序，
但是一个邻近查询允许单词可以相隔的更远或者不同的顺序。
正如模糊查询可以为单词中的字符指定最大编辑距离一样，邻近搜索允许指定短语中单词的最大编辑距离：

    "fox quick"~5

字段中的文本越接近查询字符串中指定的原始顺序，该文档就越相关。与上面的查询示例相比，
短语 `"quick fox"` 比 `"quick brown fox"` 更相关。

===== 范围

可以为日期，数字或者字符串字段指定范围。包含范围用方括号 `[min TO max]` ，
不包含范围用大括号 `{min TO max}`。

* 2012所有的天：

    date:[2012-01-01 TO 2012-12-31]

* 数字 1..5

    count:[1 TO 5]

* `alpha` 和 `omega` 之间的标签，不包含 `alpha` 和 `omega`：

    tag:{alpha TO omega}

* 10以上的数

    count:[10 TO *]

* 2012之前的日期

    date:{* TO 2012-01-01}

大括号和方括号可以组合：

* 数字从1到5但不包括5

    count:[1 TO 5}


一边无边界的范围可以使用下面的语法：

    age:>10
    age:>=10
    age:<10
    age:<=10

[NOTE]
====================================================================
用简化语法组合一个上限和下限，你需要使用 `AND` 运算符连接两个子句：

    age:(>=10 AND <20)
    age:(+>=10 +<20)

====================================================================

查询字符串的范围解析可能很复杂且容易出错。
使用显式的 <<query-dsl-range-query,`范围` 查询>>更可靠。

===== 提升

使用提升运算符 `^` 让一个词比另一个词更相关。例如，如果我们想查找关于foxes的所有文档，
但是我们对quick foxes特别感兴趣：

    quick^2 fox

默认的 `boost` 值是1，但可以是任何正浮点数。在0和1之间会降低相关性。

提升也可以应用于短语或者群组：

    "john smith"^2   (foo bar)^4

===== 布尔运算符

默认情况下，只要一个词匹配，所有词都是可选的。
搜索 `foo bar baz` 将找到包含一个或者多个 `foo` 或者 `bar` 或者 `baz` 的任何文档。
我们已经讨论了上面的 `default_operator`，它允许你强制所有词是必须的，
但也可以在查询字符串本身使用布尔运算符来提供更多的控制。

首选运算符是 `+` （这个词必须存在）和 `-` （这个词必须不存在）。所有其他词都是可选的。
例如，这个查询：

    quick brown +fox -news

说明：

* `fox` 必须存在
* `news` 一定不存在
* `quick` 和 `brown` 是可选的 -- 它们的存在增加了相关性

也支持熟悉的布尔运算符 `AND`， `OR` 和 `NOT` （也写成 `&&`， `||` 和 `!`），
但是要注意它们不遵循通常的优先级规则，所以每当多个运算符一起使用时，应该使用括号。
例如上一个查询可以重写为：

`((quick AND fox) OR (brown AND fox) OR fox) AND NOT news`::

这个语句现在可以正确地复制原始查询的逻辑，但是相关性评分与原始查询几乎没有相似之处。

相比之下，使用 <<query-dsl-match-query,`match` 查询>> 重写的相同查询，如下所示：

    {
        "bool": {
            "must":     { "match": "fox"         },
            "should":   { "match": "quick brown" },
            "must_not": { "match": "news"        }
        }
    }


===== 分组

可以将多个词或者子句与括号组合在一起，以形成子查询：

    (quick OR brown) AND fox

组可用于指定一个特定字段，或者提升子查询的结果：

    status:(active OR pending) title:(full text search)^2

===== 保留字符

如果你需要在查询本身中使用任何作为运算符的字符（而不是运算符），那么你应该使用前导反斜杠转义它们。
例如，搜索 `(1+1)=2`，你需要把查询写成 `\(1\+1\)\=2`。

保留字符是：  `+ - = && || > < ! ( ) { } [ ] ^ " ~ * ? : \ /`

无法正确转义这些特殊字符的话会导致语法错误，从而阻止查询的运行。

NOTE: `<` 和 `>` 无法转义。唯一阻止它们运行范围查询的办法是从查询字符串中完全地删除它们。

===== 空查询

如果查询字符串是空的或者只包含空格，查询将生成一个空的结果集。
