[[search-aggregations-bucket-adjacency-matrix-aggregation]]
=== 邻接矩阵(adjacency_matrix)聚合

一种以 https://zh.wikipedia.org/wiki/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5[邻接矩阵] 为返回形式的 bucket 聚合。
在请求中提供了命名过滤器表达式的集合，类似于 `（过滤器）filters` 聚合的请求。
在响应中，每个 bucket 表示邻接矩阵中的一个非空的 cell。

beta[ `adjacency_matrix` 聚合是一种新特性，我们会根据实际使用中的反馈来改进这个设计。因此，该特性的 API 之后的修改可能并非向后兼容的]

若有三个名为 `A` ，`B` 和 `C` 的过滤器，那响应中也会有三个以此命名的 bucket:

[options="header"]
|=======================
|  h|A   h|B  h|C   
h|A |A   |A&B |A&C 
h|B |    |B   |B&C 
h|C |    |    |C  
|=======================

那些相交的 bucket 会使用两个过滤器名称的组合进行标记，在过滤器名称中间使用 & 符号分割，例如 `A&C` 。需要注意的是，响应中不会包含 `C&A` bucket，因为它和 `A&C` 是相同的一组文档。这个矩阵是 _symmetric（对称的）_ 所以我们只返回它的一半。为此，我们用过滤器进行了字符排序，并始终使用两个字符串中最小的作为 "&" 分隔符左边的值。

如果客户端希望使用其他字符串作为分割字符串来替代默认的 & 符号，可以在请求中传递一个 `separator` 参数。


示例:

[source,js]
--------------------------------------------------
PUT /emails/_doc/_bulk?refresh
{ "index" : { "_id" : 1 } }
{ "accounts" : ["hillary", "sidney"]}
{ "index" : { "_id" : 2 } }
{ "accounts" : ["hillary", "donald"]}
{ "index" : { "_id" : 3 } }
{ "accounts" : ["vladimir", "donald"]}

GET emails/_search
{
  "size": 0,
  "aggs" : {
    "interactions" : {
      "adjacency_matrix" : {
        "filters" : {
          "grpA" : { "terms" : { "accounts" : ["hillary", "sidney"] }},
          "grpB" : { "terms" : { "accounts" : ["donald", "mitt"] }},
          "grpC" : { "terms" : { "accounts" : ["vladimir", "nigel"] }}
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE

在上面的示例中，我们分析了电子邮件信息，用来查询互发了邮件的几组用户。
我们会获得一个组数量的计数，还有每组发送信息量的计数。

返回:

[source,js]
--------------------------------------------------
{
  "took": 9,
  "timed_out": false,
  "_shards": ...,
  "hits": ...,
  "aggregations": {
    "interactions": {
      "buckets": [
        {
          "key":"grpA",
          "doc_count": 2
        },
        {
          "key":"grpA&grpB",
          "doc_count": 1
        },
        {
          "key":"grpB",
          "doc_count": 2
        },
        {
          "key":"grpB&grpC",
          "doc_count": 1
        },
        {
          "key":"grpC",
          "doc_count": 1
        }
      ]
    }
  }
}
--------------------------------------------------
// TESTRESPONSE[s/"took": 9/"took": $body.took/]
// TESTRESPONSE[s/"_shards": \.\.\./"_shards": $body._shards/]
// TESTRESPONSE[s/"hits": \.\.\./"hits": $body.hits/]

==== 用途
这种聚合本身可以提供创建无向加权图所需的所有数据。然而，当其他的子聚合一起使用时会更有价值，例如与 `date_histogram` 聚合一起使用时，其产生的结果可以为 https://en.wikipedia.org/wiki/Dynamic_network_analysis[动态网络分析] 提供额外随时间变化的交互数据。

==== 限制
N 个过滤器可以产生 N²/2 个 bucket 矩阵，所以过滤器的数量有一个默认的最大值 100 。可以在索引级别的设置中使用 `index.max_adjacency_matrix_filters` 修改这项设置。
