[[search-aggregations-pipeline]]

== Pipeline（管道）聚合

pipeline 聚合工作在其他聚合输出生成物的地方，而不是直接处理文档，它用于向输出树中添加信息。pipeline 聚合有很多不同的类型，它们为其他聚合处理各种各样的信息，但是这么多的类型可以大致分为两类：

_Parent（父辈）_::
                这类管道聚合包含了 paraent 聚合的输出，它可以为已经存在的 bucket 添加新计算的 bucket 或者新的聚合。
_Sibling（同辈）_::
                这一类管道聚合会提供 sibling 聚合的输出，同时它可以计算一个新的聚合，新的聚合会在作为 sibling 聚合出现在同一级。

pipeline 聚合可以通过使用 `buckets_path` 参数来指定执行计算指标所需聚合的路径。定义这些路径的语法可以在下面的 <<buckets-path-syntax, `buckets_path` 语法>> 部分找到。

pipeline 聚合不能使用子聚合，但是它根据类型的区分可以使用 `buckets_path` 来链接其他 pipeline 聚合。例如，你可以链接其他两个导数计算二阶导数（即导数的导数）。

NOTE: 由于 pipeline 聚合仅将数据合并输出，因此在链接 pipeline 聚合时，最终输出将包含每个 pipeline 聚合的输出。

[[buckets-path-syntax]]
[float]
=== `buckets_path` 语法

大多数 pipeline 聚合需要另一个聚合作为输入。输入聚合是通过 `buckets_path` 参数定义的，该参数遵循特定的格式：

// https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F
[source,ebnf]
--------------------------------------------------
AGG_SEPARATOR       =  '>' ;
METRIC_SEPARATOR    =  '.' ;
AGG_NAME            =  <聚合的名称> ;
METRIC              =  <指标的名称(对于多指标聚合)> ;
PATH                =  <AGG_NAME> [ <AGG_SEPARATOR>, <AGG_NAME> ]* [ <METRIC_SEPARATOR>, <METRIC> ] ;
--------------------------------------------------

例如，路径 `"my_bucket>my_stats.avg"` 会将 `avg` 的值指定为 `"my_stats"` 的指标，它包含在名为 `“my_bucket”` 的 bucket 聚合中。

path 参数是对 pipline 聚合的相对位置；参数中不能填入绝对路径，而且路径无法被上一级的聚合调用。例如，这个移动平均值嵌入到了一个 date_histogram 中，并且引用了一个 sibling 聚合的指标 `"the_sum"`：

[source,js]
--------------------------------------------------
POST /_search
{
    "aggs": {
        "my_date_histo":{
            "date_histogram":{
                "field":"timestamp",
                "interval":"day"
            },
            "aggs":{
                "the_sum":{
                    "sum":{ "field": "lemmings" } <1>
                },
                "the_movavg":{
                    "moving_avg":{ "buckets_path": "the_sum" } <2>
                }
            }
        }
    }
}
--------------------------------------------------
// CONSOLE
// TEST[warning: moving_avg 聚合已经被废弃了，取而代之的是 moving_fn 聚合。]
<1> 这个指标名称为 `"the_sum"`
<2> The `buckets_path` 通过相对路径引用 `"the_sum"` 

`buckets_path` 也可用于 sibling pipeline 聚合，这些聚合会变成 bucket 的“下一个”聚合，而不是嵌入到这些 bucket 中。例如，`max_bucket` 聚合使用 `buckets_path` 指定了嵌入到 sibling 聚合中的指标：

[source,js]
--------------------------------------------------
POST /_search
{
    "aggs" : {
        "sales_per_month" : {
            "date_histogram" : {
                "field" : "date",
                "interval" : "month"
            },
            "aggs": {
                "sales": {
                    "sum": {
                        "field": "price"
                    }
                }
            }
        },
        "max_monthly_sales": {
            "max_bucket": {
                "buckets_path": "sales_per_month>sales" <1>
            }
        }
    }
}
--------------------------------------------------
// CONSOLE
// TEST[setup:sales]
<1> `buckets_path` 指定了使用 `max_bucket` 聚合嵌入到 `sales_per_month` 日期直方图中，这个聚合会取出 `sales` 聚合中的最大值。
`buckets_path` instructs this max_bucket aggregation that we want the maximum value of the `sales` aggregation in the
`sales_per_month` date histogram.

[float]
=== 特殊路径

Instead of pathing to a metric, `buckets_path` can use a special `"_count"` path.  This instructs
the pipeline aggregation to use the document count as its input.  For example, a moving average can be calculated on the document count of each bucket, instead of a specific metric:

[source,js]
--------------------------------------------------
POST /_search
{
    "aggs": {
        "my_date_histo": {
            "date_histogram": {
                "field":"timestamp",
                "interval":"day"
            },
            "aggs": {
                "the_movavg": {
                    "moving_avg": { "buckets_path": "_count" } <1>
                }
            }
        }
    }
}
--------------------------------------------------
// CONSOLE
// TEST[warning:The moving_avg aggregation has been deprecated in favor of the moving_fn aggregation.]
<1> By using `_count` instead of a metric name, we can calculate the moving average of document counts in the histogram

The `buckets_path` can also use `"_bucket_count"` and path to a multi-bucket aggregation to use the number of buckets
returned by that aggregation in the pipeline aggregation instead of a metric. for example a `bucket_selector` can be
used here to filter out buckets which contain no buckets for an inner terms aggregation:

[source,js]
--------------------------------------------------
POST /sales/_search
{
  "size": 0,
  "aggs": {
    "histo": {
      "date_histogram": {
        "field": "date",
        "interval": "day"
      },
      "aggs": {
        "categories": {
          "terms": {
            "field": "category"
          }
        },
        "min_bucket_selector": {
          "bucket_selector": {
            "buckets_path": {
              "count": "categories._bucket_count" <1>
            },
            "script": {
              "source": "params.count != 0"
            }
          }
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[setup:sales]
<1> By using `_bucket_count` instead of a metric name, we can filter out `histo` buckets where they contain no buckets
for the `categories` aggregation

[[dots-in-agg-names]]
[float]
=== Dealing with dots in agg names

An alternate syntax is supported to cope with aggregations or metrics which
have dots in the name, such as the ++99.9++th
<<search-aggregations-metrics-percentile-aggregation,percentile>>. This metric
may be referred to as:

[source,js]
---------------
"buckets_path": "my_percentile[99.9]"
---------------
// NOTCONSOLE

[[gap-policy]]
[float]
=== Dealing with gaps in the data

Data in the real world is often noisy and sometimes contains *gaps* -- places where data simply doesn't exist.  This can
occur for a variety of reasons, the most common being:

* Documents falling into a bucket do not contain a required field
* There are no documents matching the query for one or more buckets
* The metric being calculated is unable to generate a value, likely because another dependent bucket is missing a value.
Some pipeline aggregations have specific requirements that must be met (e.g. a derivative cannot calculate a metric for the
first value because there is no previous value, HoltWinters moving average need "warmup" data to begin calculating, etc)

Gap policies are a mechanism to inform the pipeline aggregation about the desired behavior when "gappy" or missing
data is encountered.  All pipeline aggregations accept the `gap_policy` parameter.  There are currently two gap policies
to choose from:

_skip_::
                This option treats missing data as if the bucket does not exist.  It will skip the bucket and continue
                calculating using the next available value.

_insert_zeros_::
                This option will replace missing values with a zero (`0`) and pipeline aggregation computation will
                proceed as normal.




include::pipeline/avg-bucket-aggregation.asciidoc[]
include::pipeline/derivative-aggregation.asciidoc[]
include::pipeline/max-bucket-aggregation.asciidoc[]
include::pipeline/min-bucket-aggregation.asciidoc[]
include::pipeline/sum-bucket-aggregation.asciidoc[]
include::pipeline/stats-bucket-aggregation.asciidoc[]
include::pipeline/extended-stats-bucket-aggregation.asciidoc[]
include::pipeline/percentiles-bucket-aggregation.asciidoc[]
include::pipeline/movavg-aggregation.asciidoc[]
include::pipeline/movfn-aggregation.asciidoc[]
include::pipeline/cumulative-sum-aggregation.asciidoc[]
include::pipeline/bucket-script-aggregation.asciidoc[]
include::pipeline/bucket-selector-aggregation.asciidoc[]
include::pipeline/bucket-sort-aggregation.asciidoc[]
include::pipeline/serial-diff-aggregation.asciidoc[]
